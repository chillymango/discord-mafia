"""
Generate the config objects from a google sheet
"""
import asyncio
import json
import typing as T

from aiogoogle.auth.creds import ServiceAccountCreds

from engine.config import SheetsFetcher
from engine.role import NAME_TO_ROLE
from util.string import camel_to_snake
from util.string import fmt_to_field


if __name__ == "__main__":
    with open('service_token.json') as service_token:
        token = json.loads(service_token.read())

    creds = ServiceAccountCreds(**token)
    fetch = SheetsFetcher(creds)
    SHEET_ID = '1PMiXU_B2eATCXlZuFsEuKFa9KjDCSWdC9ONlQ6OZY6Q'

    async def main() -> None:
        #await fetch.fetch_config(SHEET_ID)
        await fetch.fetch_all_role_configs(SHEET_ID)
        class_name_map: T.Dict[str, str] = dict()
        snake_name_map: T.Dict[str, str] = dict()
        for role_name, raw_spec in fetch.read_results.items():
            klass_name = f"{role_name}Section"
            class_name_map[role_name] = klass_name
            snake_name = camel_to_snake(role_name)
            snake_name_map[role_name] = snake_name
            output_name = f"{snake_name}.py"
            fmt = f"""# this file is automatically generated by engine/config/gen.py


import typing as T
from pydantic import Field
from engine.config import Section


class {klass_name}(Section):

    @staticmethod
    def sheet_range() -> T.Tuple[str, str, str]:
        return ("{role_name}", "A1", "B15")

    @staticmethod
    def ingest(sheet_section: T.List[T.List[str]]) -> T.Dict[str, str]:
        return dict([
            (sheet_section[idx][0], sheet_section[idx][1])
            for idx in range(len(sheet_section))
        ])
"""
            for row in raw_spec:
                if not row:
                    break

                name, orig = row

                value = None
                try:
                    # if it's a numeric type, set that
                    value = int(orig)  # this should always be an integer
                except (TypeError, ValueError):
                    # try a boolean instead
                    pass

                if value is None:
                    if orig.lower() == "true":
                        value = True
                    elif orig.lower() == "false":
                        value = False

                if value is None:
                    # otherwise just default to string
                    value = str(value)

                fmt += f"\n    {fmt_to_field(name)}: {type(value).__name__} = {value}"

            fmt += "\n"

            with open(f"engine\\config\\{output_name}", "w+") as output_file:
                output_file.write(fmt)

    # build the main config object
        config = f"""# this file is automatically generated by engine/config/gen.py

    
import typing as T
from pydantic import BaseModel
from pydantic import Field
from engine.config import Section
from util.string import camel_to_snake

if T.TYPE_CHECKING:
    from engine.role.base import Role

"""
        # add config imports
        for role_name in fetch.read_results:
            config += f"from engine.config.{snake_name_map[role_name]} import {class_name_map[role_name]}\n"

        config += f"""

class RoleConfigMixin(BaseModel):
"""
        for role_name, klass_name in class_name_map.items():
            config += f"    {camel_to_snake(role_name)}: {klass_name} = Field(default_factory={klass_name})\n"

        config += """
    @classmethod
    def get_list_of_sections(cls) -> T.List[T.Type["Section"]]:
        return [field.type_ for field in cls.__fields__.values()]

    @classmethod
    def construct_from_sections(cls, sections: T.List["Section"]) -> "RoleConfigMixin":
        \"\"\"
        Match sections by type.

        If there's a missing type we just use default for construction.
        \"\"\"
        reverse_lookup: T.Dict[T.Type["Section"], str] = dict()
        for field_name, field in cls.__fields__.items():
            reverse_lookup[field.type_] = field_name

        constructor_dict: T.Dict[str, "Section"] = dict()
        for section in sections:
            constructor_dict[reverse_lookup[type(section)]] = section

        return cls(**constructor_dict)

"""

        with open(f"engine\\config\\game.py", "w+") as game_output:
            game_output.write(config)

    asyncio.run(main())
